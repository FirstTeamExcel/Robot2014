// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "Camera.h"
#include "../Robotmap.h"
#include "Vision/RGBImage.h"
#include "Vision/ColorImage.h"

Camera::Camera() : Subsystem("Camera") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
  
}
    
void Camera::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void Camera::Test()
{

  ColorImage *image;
  image = new RGBImage("/TestImage.jpg");
  BinaryImage *thresholdImage = image->ThresholdHSV(threshold);
  BinaryImage *convexHullIMage = thresholdImage->ConvexHull(false);
  BinaryImage *filtredImage = convexHullIMage->ParticleFilter(criteria, 1);

  vector<ParticleAnalysisReport>* reports = filtredImage->GetOrderedParticleAnalysisReports();
  
  if(reports->size() > 0)
    {
      scores = new Scores[reports->size()];
      for (unsigned int i = 0; i < MAX_PARTICLES && i < reports->size(); i++) {
             ParticleAnalysisReport *report = &(reports->at(i));
                                          
             //Score each particle on rectangularity and aspect ratio
             scores[i].rectangularity = scoreRectangularity(report);
             scores[i].aspectRatioVertical = scoreAspectRatio(filteredImage, report, true);
             scores[i].aspectRatioHorizontal = scoreAspectRatio(filteredImage, report, false);                       
                                          
             //Check if the particle is a horizontal target, if not, check if it's a vertical target
             if(scoreCompare(scores[i], false))
             {
                 printf("particle: %d  is a Horizontal Target centerX: %d  centerY: %d \n", i, report->center_mass_x, report->center_mass_y);
                 horizontalTargets[horizontalTargetCount++] = i; //Add particle to target array and increment count
             } else if (scoreCompare(scores[i], true)) {
                 printf("particle: %d  is a Vertical Target centerX: %d  centerY: %d \n", i, report->center_mass_x, report->center_mass_y);
                 verticalTargets[verticalTargetCount++] = i;  //Add particle to target array and increment count
             } else {
                 printf("particle: %d  is not a Target centerX: %d  centerY: %d \n", i, report->center_mass_x, report->center_mass_y);
             }
      printf("Scores rect: %f  ARvert: %f \n", scores[i].rectangularity, scores[i].aspectRatioVertical);
      printf("ARhoriz: %f  \n", scores[i].aspectRatioHorizontal);     
      }

      //Zero out scores and set verticalIndex to first target in case there are no horizontal targets
      target.totalScore = target.leftScore = target.rightScore = target.tapeWidthScore = target.verticalScore = 0;
      target.verticalIndex = verticalTargets[0];
      for (int i = 0; i < verticalTargetCount; i++)
      {
          ParticleAnalysisReport *verticalReport = &(reports->at(verticalTargets[i]));
          for (int j = 0; j < horizontalTargetCount; j++)
            {
              ParticleAnalysisReport *horizontalReport = &(reports->at(horizontalTargets[j]));
              double horizWidth, horizHeight, vertWidth, leftScore, rightScore, tapeWidthScore, verticalScore, total;
          
              //Measure equivalent rectangle sides for use in score calculation
              imaqMeasureParticle(filteredImage->GetImaqImage(), horizontalReport->particleIndex, 0, IMAQ_MT_EQUIVALENT_RECT_LONG_SIDE, &horizWidth);
              imaqMeasureParticle(filteredImage->GetImaqImage(), verticalReport->particleIndex, 0, IMAQ_MT_EQUIVALENT_RECT_SHORT_SIDE, &vertWidth);
              imaqMeasureParticle(filteredImage->GetImaqImage(), horizontalReport->particleIndex, 0, IMAQ_MT_EQUIVALENT_RECT_SHORT_SIDE, &horizHeight);
                                                  
              //Determine if the horizontal target is in the expected location to the left of the vertical target
              leftScore = ratioToScore(1.2*(verticalReport->boundingRect.left - horizontalReport->center_mass_x)/horizWidth);
              //Determine if the horizontal target is in the expected location to the right of the  vertical target
              rightScore = ratioToScore(1.2*(horizontalReport->center_mass_x - verticalReport->boundingRect.left - verticalReport->boundingRect.width)/horizWidth);
              //Determine if the width of the tape on the two targets appears to be the same
              tapeWidthScore = ratioToScore(vertWidth/horizHeight);
              //Determine if the vertical location of the horizontal target appears to be correct
              verticalScore = ratioToScore(1-(verticalReport->boundingRect.top - horizontalReport->center_mass_y)/(4*horizHeight));
              total = leftScore > rightScore ? leftScore:rightScore;
              total += tapeWidthScore + verticalScore;
                                                  
              //If the target is the best detected so far store the information about it
              if(total > target.totalScore)
                {
                  target.horizontalIndex = horizontalTargets[j];
                  target.verticalIndex = verticalTargets[i];
                  target.totalScore = total;
                  target.leftScore = leftScore;
                  target.rightScore = rightScore;
                  target.tapeWidthScore = tapeWidthScore;
                  target.verticalScore = verticalScore;
                }
            }
          //Determine if the best target is a Hot target
          target.Hot = hotOrNot(target);
      }
        
      ParticleAnalysisReport *report = reports->at(i);
//      ParticleAnalysisReport *report = (ParticleAnalysisReport *)(reports->at(i));
    };
}
