// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ShooterWheels.h"
#include "../Robotmap.h"
#include "../Commands/ShooterIdle.h"
ShooterWheels::ShooterWheels() : Subsystem("ShooterWheels") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	rightWheelMotor = RobotMap::shooterWheelsrightWheelMotor;
	leftWheelMotor = RobotMap::shooterWheelsleftWheelMotor;
	leftCounter = RobotMap::shooterWheelsleftCounter;
	rightCounter = RobotMap::shooterWheelsrightCounter;
	firingSolenoid = RobotMap::shooterWheelsFiringSolenoid;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
	ready = true;
	shotTimer.Start();
}
    
void ShooterWheels::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new ShooterIdle());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
// Put methods for controlling this subsystem
// here. Call these from Commands.

void ShooterWheels::SetTargetRpm(float targetRpm, float bias)
{
	if(targetRpm == 0)
	{
		targetSPR_Right = 0;
		targetSPR_Left = 0;
		targetSPR_Right_UpperLimit = 0;
		targetSPR_Left_UpperLimit = 0;
		targetSPR_Left_LowerLimit = 0;
		targetSPR_Right_LowerLimit = 0;
	}
	else
	{ 
		float rightTargetRpm;
		float leftTargetRpm;
		if (bias != 0.0)
		{
			rightTargetRpm = targetRpm * (1.0 + bias);
			leftTargetRpm = targetRpm * (1.0 - bias);
		}
		else
		{
			rightTargetRpm = targetRpm;
			leftTargetRpm = targetRpm;
		}
		
		if(rightTargetRpm > MAX_RPM)
		{
			rightTargetRpm = MAX_RPM;
		}
		
		if(leftTargetRpm > MAX_RPM)
		{
			leftTargetRpm = MAX_RPM;
		}
		
		targetSPR_Right = ((double)60.0) / ((double)rightTargetRpm);
		targetSPR_Left = ((double)60.0) / ((double)leftTargetRpm);
		targetSPR_Right_UpperLimit = (targetSPR_Right * (1.0 + SPEED_TOLERANCE));
		targetSPR_Left_UpperLimit = (targetSPR_Left * (1.0 + SPEED_TOLERANCE));
		targetSPR_Right_LowerLimit = (targetSPR_Right * (1.0 - SPEED_TOLERANCE));
		targetSPR_Left_LowerLimit = (targetSPR_Left * (1.0 - SPEED_TOLERANCE));
	}
}

void ShooterWheels::SetPower(float power)
{
	rightWheelMotor->Set(power);
	leftWheelMotor->Set(power);
}
void ShooterWheels::GetRpm(float& rightRpm, float& leftRpm)
{
	rightRpm = (60.0 / rightCount.GetPeriod());
	leftRpm = (60.0 / leftCount.GetPeriod());
}
bool ShooterWheels::Fire(float delay)
{
	static Timer takeBackTimer;
	static Timer shotTimer;
	static bool ready = true;
	bool returnValue = false;
	if ((IsUpToSpeed() == true) && (ready == true) && (shotTimer.Get() > BALL_ESCAPE_TIME))
		{
			takeBack = true;
			firingSolenoid->Set(DoubleSolenoid::kForward);
			takeBackTimer.Reset();
			takeBackTimer.Start();
			shotTimer.Start();
			shotTimer.Reset();
			ready = false;
			returnValue = true;
			return true;
		}
	// This function takes the takeBack back, Jack
	else if (shotTimer.Get() > delay)
	{
		shotTimer.Reset();
		ready = true;
		firingSolenoid->Set(DoubleSolenoid::kReverse);
	}
	else if(shotTimer.Get() == 0.0)
	{
		shotTimer.Start();
	}
	
	if (takeBackTimer.Get() >= TAKE_BACK_TIME)
	{
		takeBack = false;
	}
	return returnValue;
}

void ShooterWheels::Run()
{
	static float lastRightMotorCommand;
	static float lastLeftMotorCommand;
	float newRightMotorCommand;
	float newLeftMotorCommand;
	rightCurrentSpeed = rightCount.GetPeriod();
	leftCurrentSpeed = leftCount.GetPeriod();
	
	if (takeBack)
		{
			newRightMotorCommand = 0.8;
			newLeftMotorCommand = 0.8;
		}
	else if (targetRpm == 0.0)
		{
			newRightMotorCommand = 0.0;
			newLeftMotorCommand = 0.0;
		}
	else
		{
			if (rightCurrentSpeed > targetSPR_Right)
				{
					newRightMotorCommand = 1.0;
				}
			if (leftCurrentSpeed > targetSPR_Left)
				{
					newLeftMotorCommand = 1.0;
				}
		}

	if (lastRightMotorCommand != newRightMotorCommand)
		{
			rightWheelMotor->Set(newRightMotorCommand);
			lastRightMotorCommand = newRightMotorCommand;
		}

	if (lastLeftMotorCommand != newLeftMotorCommand)
		{
			leftWheelMotor->Set(newLeftMotorCommand);
			lastLeftMotorCommand = newLeftMotorCommand;
		}
}

bool ShooterWheels::IsUpToSpeed()
{
	//make sure we don't return true if the target is 0
	if (targetSPR_Right == 0.0)
	{
		return false;
	}
	double rightSpeed = rightCurrentSpeed;
	double leftSpeed = leftCurrentSpeed;
	if ((rightSpeed >= targetSPR_Right_LowerLimit) && (rightSpeed <= targetSPR_Right_UpperLimit))
		{
			rightIsUpToSpeed = true;
		}
	else
		{
			rightIsUpToSpeed = false;
		}
	
	if ((leftSpeed >= targetSPR_Left_LowerLimit) && (leftSpeed <= targetSPR_Left_UpperLimit))
		{
			leftIsUpToSpeed = true;
		}
	else
	{
		leftIsUpToSpeed = false;
	}
	
	bool atSpeed = false;
	if ((rightIsUpToSpeed == true) && (leftIsUpToSpeed == true))
	{
		atSpeed = true;
	}
	return atSpeed;
}


bool ShooterWheels::IsShotComplete()
{
	bool shotComplete = false;
	if((ready == true) && shotTimer.Get() >= 0.5)
	{
		shotComplete = true;
	}
	return shotComplete;
}
