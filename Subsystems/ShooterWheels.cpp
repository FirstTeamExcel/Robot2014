// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ShooterWheels.h"
#include "../Robotmap.h"
#include "../Commands/ShooterIdle.h"
#include "../ShooterWheelsSpeeds.h"
ShooterWheels::ShooterWheels() :
    Subsystem("ShooterWheels"),
    rightCount(6),
    leftCount(7)
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	rightWheelMotor = RobotMap::shooterWheelsrightWheelMotor;
	leftWheelMotor = RobotMap::shooterWheelsleftWheelMotor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	
	
}
void ShooterWheels::InitDefaultCommand()
{
    // Set the default command for a subsystem here.
    //SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new ShooterIdle());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void ShooterWheels::SetTargetRpm(float targetRpm, float bias)
{
	_rpmControl = true;
    if (targetRpm == 0)
    {
        targetSPR_Right = 0;
        targetSPR_Left = 0;
        targetSPR_Right_UpperLimit = 0;
        targetSPR_Left_UpperLimit = 0;
        targetSPR_Left_LowerLimit = 0;
        targetSPR_Right_LowerLimit = 0;
    }
    else
    {
        float rightTargetRpm;
        float leftTargetRpm;
        if (bias != 0.0)
        {
            rightTargetRpm = targetRpm * (1.0 + bias);
            leftTargetRpm = targetRpm * (1.0 - bias);
            _rightTakeBackPower = TAKE_BACK_POWER * (1.0 + bias);
            _leftTakeBackPower = TAKE_BACK_POWER * (1.0 - bias);
        }
        else
        {
            rightTargetRpm = targetRpm;
            leftTargetRpm = targetRpm;
            _rightTakeBackPower = TAKE_BACK_POWER;
            _leftTakeBackPower = TAKE_BACK_POWER;
        }
        if (rightTargetRpm > MAX_RPM)
        {
            rightTargetRpm = MAX_RPM;
        }
        if (leftTargetRpm > MAX_RPM)
        {
            leftTargetRpm = MAX_RPM;
        }
        if (_leftTakeBackPower > 1.0)
        {
            _leftTakeBackPower = 1.0;
        }
        if (_rightTakeBackPower > 1.0)
        {
            _rightTakeBackPower = 1.0;
        }
        targetSPR_Right = ((double) 60.0) / ((double) rightTargetRpm);
        targetSPR_Left = ((double) 60.0) / ((double) leftTargetRpm);
        targetSPR_Right_UpperLimit
                = (targetSPR_Right * (1.0 + SPEED_TOLERANCE));
        targetSPR_Left_UpperLimit = (targetSPR_Left * (1.0 + SPEED_TOLERANCE));
        targetSPR_Right_LowerLimit
                = (targetSPR_Right * (1.0 - SPEED_TOLERANCE));
        targetSPR_Left_LowerLimit = (targetSPR_Left * (1.0 - SPEED_TOLERANCE));
    }
}
void ShooterWheels::SetPower(float power, float spin_up_delay)
{
	_rpmControl = false;
	spinUpTimer.Reset();
	spinUpTimer.Start();
	_spin_up_delay = spin_up_delay;
    rightWheelMotor->Set(power);
    leftWheelMotor->Set(power);
}
void ShooterWheels::GetRpm(float& rightRpm, float& leftRpm)
{
    rightRpm = (60.0 / rightCount.GetPeriod());
    leftRpm = (60.0 / leftCount.GetPeriod());
}
void ShooterWheels::Run()
{
	if (_rpmControl == false)
	{
		return;
	}
	
    static float lastRightMotorCommand;
    static float lastLeftMotorCommand;
    float newRightMotorCommand;
    float newLeftMotorCommand;
    rightCurrentSpeed = rightCount.GetPeriod();
    leftCurrentSpeed = leftCount.GetPeriod();
    
    if (takeBack)
    {
        newRightMotorCommand = _rightTakeBackPower;
        newLeftMotorCommand = _leftTakeBackPower;
        if (takeBackTimer.HasPeriodPassed(TAKE_BACK_TIME))
        {
            takeBack = false;
        }
    }
    else if (targetRpm == 0.0)
    {
        newRightMotorCommand = 0.0;
        newLeftMotorCommand = 0.0;
    }
    else
    {
        if (rightCurrentSpeed > targetSPR_Right)
        {
            newRightMotorCommand = 1.0;
        }
        if (leftCurrentSpeed > targetSPR_Left)
        {
            newLeftMotorCommand = 1.0;
        }
    }
    if (lastRightMotorCommand != newRightMotorCommand)
    {
        rightWheelMotor->Set(newRightMotorCommand);
        lastRightMotorCommand = newRightMotorCommand;
    }
    if (lastLeftMotorCommand != newLeftMotorCommand)
    {
        leftWheelMotor->Set(newLeftMotorCommand);
        lastLeftMotorCommand = newLeftMotorCommand;
    }
}
bool ShooterWheels::IsUpToSpeed()
{
    //make sure we don't return true if the target is 0
	bool atSpeed= false;
	if (_rpmControl == false)
	{
		atSpeed = spinUpTimer.HasPeriodPassed(_spin_up_delay);
	}
	else
	{
		if (targetSPR_Right == 0.0)
		{
			return false;
		}
		double rightSpeed = rightCurrentSpeed;
		double leftSpeed = leftCurrentSpeed;
		if ((rightSpeed >= targetSPR_Right_LowerLimit) && (rightSpeed
				<= targetSPR_Right_UpperLimit))
		{
			rightIsUpToSpeed = true;
		}
		else
		{
			rightIsUpToSpeed = false;
		}
		if ((leftSpeed >= targetSPR_Left_LowerLimit) && (leftSpeed
				<= targetSPR_Left_UpperLimit))
		{
			leftIsUpToSpeed = true;
		}
		else
		{
			leftIsUpToSpeed = false;
		}
		bool atSpeed = false;
		if ((rightIsUpToSpeed == true) && (leftIsUpToSpeed == true))
		{
			atSpeed = true;
		}
	}
    return atSpeed;
}
void ShooterWheels::StartTakeBack()
{
    takeBack = true;
    takeBackTimer.Reset();
    takeBackTimer.Start();
}
