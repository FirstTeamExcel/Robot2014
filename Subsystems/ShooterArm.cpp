// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ShooterArm.h"
#include "../Robotmap.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"
#include "Math.h"
#include "../ShooterArmPositions.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
ShooterArm::ShooterArm() : PIDSubsystem("ShooterArm", 0.75, 0.16, 0.7) {
	SetAbsoluteTolerance(0.3);
	GetPIDController()->SetContinuous(false);
	LiveWindow::GetInstance()->AddActuator("ShooterArm", "PIDSubsystem Controller", GetPIDController());
	GetPIDController()->SetInputRange(2.36, 4.05);
	GetPIDController()->SetOutputRange(-0.6, 0.45);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	shooterArmPot = RobotMap::shooterArmshooterArmPot;
	shooterArmMotor = RobotMap::shooterArmshooterArmMotor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Use these to get going:
    // SetSetpoint() -  Sets where the PID controller should move the system
    //                  to
    // Enable() - Enables the PID controller.
    //Robot::lw->AddActuator("Arm","Angle",Robot::shooterArm);
}
double ShooterArm::ReturnPIDInput()
{
    // Return your input value for the PID loop
    // e.g. a sensor, like a potentiometer:
    // yourPot->SetAverageVoltage() / kYourMaxVoltage;
    //Use the same angle for all calculations
    float voltage = shooterArmPot->GetAverageVoltage();
    //keep track of the previousScaledFeedForward (static so it preserves the value)
    //and use it to tell if the F value of the PID was manually changed
//    static float previousScaledFeedForward = 0.0;
//    float currentRawFeedForward = GetPIDController()->GetF();
//    
//    //If the previous F value doesn't match the current, then we know it was adjusted manually, 
//    //and should use it as the new maximum
//    if (previousScaledFeedForward != currentRawFeedForward)
//    {
//        _maxFeedForward = currentRawFeedForward;
//    }
//    //If _maxFeedForward is 0, then our new feed forward is also 0.0
//    float newFeedForward = 0.0;
//    if (_maxFeedForward != 0.0)
//    {
//        //Use the current angle and the maxFeedForward setting to scale to a new feed forward command based on the current angle
//        newFeedForward = _maxFeedForward * cos(VOLTAGE_TO_RADIANS(voltage));//_maxFeedForward - (_maxFeedForward * cos(angle));
//    }
//    //If the feed forward value changed, then set it (if SetF takes a lot of processing, this will be more efficient)
//    if (previousScaledFeedForward != newFeedForward)
//    {
//        previousScaledFeedForward = newFeedForward;
//        PIDController *pid = GetPIDController();
//        pid->SetPID(pid->GetP(),pid->GetI(),pid->GetD(), newFeedForward);
//    }
    
    //Return angle, which is what this function is supposed to do
    return voltage;
}
void ShooterArm::UsePIDOutput(double output)
{
    // Use output to drive your system, like a motor
    // e.g. yourMotor->Set(output);
    //if (_maxFeedForward == 0.0)
    //{
    //  output = PIDOutputToMotorCommand(output);
    //} 
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	shooterArmMotor->PIDWrite(output);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
}
void ShooterArm::InitDefaultCommand()
{
    // Set the default command for a subsystem here.
    //setDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void ShooterArm::SetTargetAngle(float tgtAngle)
{
    Enable();
    GetPIDController()->SetSetpoint(DEGREES_TO_VOLTAGE(tgtAngle));
}
void ShooterArm::SetPIDF(float p, float i, float d, float f)
{
    _maxFeedForward = 0.0;
    float newFeedForward = 0.0;//_maxFeedForward * cos(GetCurrentRadians());
    GetPIDController()->SetPID(p,i,d, newFeedForward);
}
bool ShooterArm::IsOnTarget()
{
    return OnTarget();
}
float ShooterArm::GetCurrentAngle()
{
    return (VOLTAGE_TO_DEGREES(shooterArmPot->GetAverageVoltage()));
}
float ShooterArm::GetCurrentRadians()
{
    return (VOLTAGE_TO_RADIANS(shooterArmPot->GetAverageVoltage()));
}
float ShooterArm::PIDOutputToMotorCommand(double output)
{
    float currentRadians = GetCurrentRadians();
    //if currentAngle < target, rawOutput will typically be positive
    if (output > 0)
    {
        return output + (output * cos(currentRadians));
        //if current angle < 90, scaledOutput will be positive, and == rawOutput at 0degrees  
        //finalOutput = 2*rawOutput at 0deg, and ~1.5*rawOutput at 45deg and rawOutput at 90deg
        //if current angle > 90, scaledOutput will be negative, and == -rawOutput at 180degrees
        //finalOutput = rawOutput at 90 deg, and ~.5*rawOutput at 135deg, and 0 at 180deg
    }
    //if currentAngle > target, rawOutput will typically be negative
    else if (output < 0)
    {
        
        return output - (output * cos(currentRadians));
        
        //if current angle < 90, scaledOutput will be negative, and == rawOutput at 0degrees  
        //finalOutput = 0 at 0deg, and ~.5*rawOutput at 45deg and rawOutput at 90deg
        //if current angle > 90, scaledOutput will be positive, and == -rawOutput at 180degrees
        //finalOutput = rawOutput at 90 deg, and ~1.5*rawOutput at 135deg, and 2*rawOutput at 180deg
    }
    
    return 0.0;
}
ShooterArm::ShooterArmPosition ShooterArm::GetTargetPosition()
{
    return _targetPosition;
}
void ShooterArm::SetTargetPosition(ShooterArm::ShooterArmPosition position)
{
    _targetPosition = position;
    switch (_targetPosition)
    {
        case ShooterArm::LOAD:
            SetTargetAngle(SHOOTER_ARM_TARGET_LOAD_POSITION);
            break;
        case ShooterArm::EJECT:
            SetTargetAngle(SHOOTER_ARM_TARGET_EJECT_POSITION);
            break;
        case ShooterArm::LONG_GOAL:
            SetTargetAngle(ARM_TARGET_LONG_GOAL);
            break;
        case ShooterArm::SHORT_GOAL:
            SetTargetAngle(ARM_TARGET_SHORT_GOAL);
            break;
        case ShooterArm::TRUSS:
            SetTargetAngle(SHOOTER_ARM_TARGET_TRUSS);
            break;
        case ShooterArm::AUTONOMOUS_1:
            SetTargetAngle(ARM_TARGET_AUTONOMOUS_1);
            break;
        case ShooterArm::AUTONOMOUS_2:
            SetTargetAngle(ARM_TARGET_AUTONOMOUS_2);
            break;
        case ShooterArm::AUTONOMOUS_3:
            SetTargetAngle(ARM_TARGET_AUTONOMOUS_3);
            break;
        default:
            SetTargetAngle(SHOOTER_ARM_TARGET_LOAD_POSITION);
            break;
    }
}
