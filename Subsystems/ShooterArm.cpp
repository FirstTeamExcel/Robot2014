// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "ShooterArm.h"
#include "../Robotmap.h"
#include "SmartDashboard/SmartDashboard.h"
#include "LiveWindow/LiveWindow.h"
#include "Math.h"
#include "../ShooterArmPositions.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
ShooterArm::ShooterArm() : PIDSubsystem("ShooterArm", 1.0, 0.0, 0.0) {
	SetAbsoluteTolerance(0.2);
	GetPIDController()->SetContinuous(false);
	LiveWindow::GetInstance()->AddActuator("ShooterArm", "PIDSubsystem Controller", GetPIDController());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	shooterArmPot = RobotMap::shooterArmshooterArmPot;
	shooterArmMotor = RobotMap::shooterArmshooterArmMotor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	// Use these to get going:
	// SetSetpoint() -  Sets where the PID controller should move the system
	//                  to
	// Enable() - Enables the PID controller.
    //Robot::lw->AddActuator("Arm","Angle",Robot::shooterArm);
}
double ShooterArm::ReturnPIDInput() {
	// Return your input value for the PID loop
	// e.g. a sensor, like a potentiometer:
	// yourPot->SetAverageVoltage() / kYourMaxVoltage;	
	return VOLTAGE_TO_DEGREES(shooterArmPot->GetAverageVoltage());
}
void ShooterArm::UsePIDOutput(double output) {
	// Use output to drive your system, like a motor
	// e.g. yourMotor->Set(output);
	output = PIDOutputToMotorCommand(output);
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
	shooterArmMotor->PIDWrite(output);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=OUTPUT
}
void ShooterArm::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//setDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
void ShooterArm::SetTargetAngle(float tgtAngle) {
	if (IsOnTarget() != true)
	{
		GetPIDController()->SetSetpoint(tgtAngle);
	}
}
bool ShooterArm::IsOnTarget() {
	return OnTarget();
}
float ShooterArm::GetCurrentAngle() {
	return(VOLTAGE_TO_DEGREES(shooterArmPot->GetAverageVoltage()));
}
float ShooterArm::PIDOutputToMotorCommand(double output) {
	float currentTargetAngle = GetPIDController()->GetSetpoint();
	float currentAngle = GetCurrentAngle();
	float direction;
	if (currentTargetAngle < 90) {
		if (currentAngle < currentTargetAngle) {
			return output * (cos(currentAngle));
		}
		else if (currentTargetAngle < currentAngle && currentAngle < 90) {
			return output * (1 - cos(currentAngle));
		}
		else if (currentAngle > 90) {
			return output * (cos(currentAngle));
		}
	}
	else if (currentTargetAngle > 90) {
		if (currentAngle > currentTargetAngle) {
			return output * (cos(currentAngle));
		}
		else if (currentTargetAngle > currentAngle && currentAngle > 90) {
			return output * (1 - cos(currentAngle));
		}
		else if (currentAngle < 90) {
			return output * (1 - cos(currentAngle));
		}
	}
	return 0.0;
}
ShooterArm::ShooterArmPosition ShooterArm::GetTargetPosition()
{
	return _targetPosition;
}
void ShooterArm::SetTargetPosition(ShooterArm::ShooterArmPosition position)
{
	_targetPosition = position;
	switch(_targetPosition)
	{
	case ShooterArm::LOAD:
		SetTargetAngle(SHOOTER_ARM_TARGET_LOAD_POSITION);
		break;
	case ShooterArm::EJECT:
		SetTargetAngle(SHOOTER_ARM_TARGET_EJECT_POSITION);
		break;
	case ShooterArm::LONG_GOAL:
		SetTargetAngle(ARM_TARGET_LONG_GOAL);
		break;
	case ShooterArm::SHORT_GOAL:
		SetTargetAngle(ARM_TARGET_SHORT_GOAL);
		break;
	case ShooterArm::TRUSS:
		SetTargetAngle(SHOOTER_ARM_TARGET_TRUSS);
		break;
	case ShooterArm::AUTONOMOUS_1:
		SetTargetAngle(ARM_TARGET_AUTONOMOUS_1);
		break;
	case ShooterArm::AUTONOMOUS_2:
		SetTargetAngle(ARM_TARGET_AUTONOMOUS_2);
		break;
	case ShooterArm::AUTONOMOUS_3:
		SetTargetAngle(ARM_TARGET_AUTONOMOUS_3);
		break;
	default:
		SetTargetAngle(SHOOTER_ARM_TARGET_LOAD_POSITION);
		break;
	}
}
