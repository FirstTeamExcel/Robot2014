// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include "DriveSubsystem.h"
#include "../Robotmap.h"
#include "../Commands/CheesyDrive.h" // TODO used cheesy
#include "../Commands/Drive.h"
#define AUTON_SPEED_CORRECT_FACTOR 7
volatile float _speed = 0.0;
volatile float _turn = 0.0;
void SetSpeed(float output);
void SetTurn(float output);
float autonTurnAmount = 0; 
DriveSubsystem::DriveSubsystem() :
    Subsystem("DriveSubsystem")//, driveOutput(), turnOutput(),
            //turnToAngleOutput(RobotMap::driveSubsystemTheDriveTrain)
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	leftDrive = RobotMap::driveSubsystemleftDrive;
	rightDrive = RobotMap::driveSubsystemrightDrive;
	theDriveTrain = RobotMap::driveSubsystemTheDriveTrain;
	leftEncoder = RobotMap::driveSubsystemleftEncoder;
	rightEncoder = RobotMap::driveSubsystemrightEncoder;
	driveGyro = RobotMap::driveSubsystemdriveGyro;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
//    leftEncoder->SetPIDSourceParameter(PIDSource::kDistance);
//    rightEncoder->SetPIDSourceParameter(PIDSource::kDistance);
//    leftEncoder->SetDistancePerPulse(INCHES_PER_PULSE);
//    rightEncoder->SetDistancePerPulse(INCHES_PER_PULSE);
//    driveStraightPID = new PIDController(DRIVE_STRAIGHT_P, DRIVE_STRAIGHT_I,
//            DRIVE_STRAIGHT_D, driveGyro, &turnOutput);
//    driveDistancePID = new PIDController(DRIVE_DISTANCE_P, DRIVE_DISTANCE_I,
//            DRIVE_DISTANCE_D, leftEncoder, &driveOutput);
//    turnToAnglePID = new PIDController(TURN_ANGLE_P, TURN_ANGLE_I,
//            TURN_ANGLE_D, driveGyro, &turnToAngleOutput);
//    driveOutput.SetOutputCallback(&SetSpeed);
//    turnOutput.SetOutputCallback(&SetTurn); 
    
//    LiveWindow *lw = LiveWindow::GetInstance();
//    lw->AddActuator("DriveSubsystem", "StraightPID", driveStraightPID);
//    lw->AddActuator("DriveSubsystem", "DistancePID", driveDistancePID);
//    lw->AddActuator("DriveSubsystem", "TurnPID", turnToAnglePID);
        
}
void DriveSubsystem::InitDefaultCommand()
{
    // Set the default command for a subsystem here.
    //SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new Drive());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void DriveSubsystem::DriveStraight(float speedToDrive, bool useGyro)
{
	static bool hasError = false;
	float gyro_angle = driveGyro->GetAngle();
	float autonSpeedCorrect = 0;
	if ((gyro_angle > 90.0) || (gyro_angle < -90.0) || (gyroOffTargetTimer.Get() > 1.0))
	{
		gyro_angle = 0.0;
		if (hasError == false)
		{
			printf("The gyro reported %f as angle... Way off", gyro_angle);
			hasError = true;
		}
	}
	else if ((gyro_angle > 30.0) || (gyro_angle < -30.0))
	{
		gyroOffTargetTimer.Start();
	}
	else
	{
		gyroOffTargetTimer.Reset();
	}
	
	float autonTurnAmount = gyro_angle / 50.0f;
			if (autonTurnAmount > 0.2) autonTurnAmount = 0.2;
			if (autonTurnAmount < -0.2) autonTurnAmount = -0.2;
			autonSpeedCorrect = (autonTurnAmount) * AUTON_SPEED_CORRECT_FACTOR;
			if (autonSpeedCorrect < 0.0) autonSpeedCorrect = autonSpeedCorrect * -1.0;
			
//			if (useGyro == false)
//			{
//                autonSpeedCorrect = 0.0;
//                autonTurnAmount = 0.0;
//			}
		    //theDriveTrain->Drive(speedToDrive + autonSpeedCorrect, -autonTurnAmount);
		    theDriveTrain->Drive(speedToDrive , autonTurnAmount);
	
	
	
	
    //bool retValue = false;
    //return retValue;
}
//bool DriveSubsystem::DriveStraight(float speedToDrive)
//{
//}
//    static Timer onTargetTimer;
//    
//    driveDistancePID->SetSetpoint(inchesToDrive);
//    if (inchesToDrive > 0.0)
//    {
//        
//        driveDistancePID->SetOutputRange(-0.3, 0.8);
//    }
//    else
//    {
//        
//        driveDistancePID->SetOutputRange(-0.8, 0.3);
//    }
//    driveStraightPID->SetSetpoint(0.0);
//    
//    if (driveDistancePID->IsEnabled() == false)
//    {
//        driveDistancePID->Enable();
//        driveStraightPID->Enable();
//    }
//    
//    if (driveDistancePID->OnTarget())
//    {
//        if (onTargetTimer.Get() == 0.4)
//        {
//            driveDistancePID->Disable();
//            driveStraightPID->Disable();
//            theDriveTrain->Drive(0.0, 0.0);
//            retValue = true;
//        }
//    }
//    else
//    {
//        onTargetTimer.Reset();
//        onTargetTimer.Start();
//        theDriveTrain->Drive(driveOutput.GetOutput(), turnOutput.GetOutput());
//    }
bool DriveSubsystem::TurnToAngle(float totalTurnAngle)
{
    bool retValue = false;
//    static Timer onTargetTimer;
//    if (turnToAnglePID->IsEnabled() == false)
//    {
//        float turnedAngle = driveGyro->GetAngle() + totalTurnAngle;
//        turnToAnglePID->SetSetpoint(turnedAngle);
//        turnToAnglePID->Enable();
//    }
//    if (turnToAnglePID->OnTarget())
//    {
//        if (onTargetTimer.Get() == 0.4)
//        {
//            theDriveTrain->Drive(0.0, 0.0);
//            turnToAnglePID->Disable();
//            retValue = true;
//        }
//    }
//    else
//    {
//        onTargetTimer.Reset();
//        onTargetTimer.Start();
//    }
    return retValue;
}
void DriveSubsystem::Cancel()
{
//    theDriveTrain->Drive(0.0, 0.0);
//	turnToAnglePID->Disable();
//	driveDistancePID->Disable();
//	driveStraightPID->Disable();
}
void SetTurn(float output)
{
    _turn = output;
//    theDriveTrain->Drive(_speed,_turn);
}
void SetSpeed(float output)
{
    _speed = output;
    Robot::driveSubsystem->theDriveTrain->Drive(_speed,_turn);
}
void FunWithTimers()
{
	Timer driveTimer;
	float driveTime = driveTimer.Get();
	driveTimer.Reset();
	driveTimer.Start();
	if (driveTime < 2.0)
	{
		Robot::driveSubsystem->theDriveTrain->Drive(0.5,0.0);
	}
	else
	{
		Robot::driveSubsystem->theDriveTrain->Drive(0.0,0.0);
	}
}
